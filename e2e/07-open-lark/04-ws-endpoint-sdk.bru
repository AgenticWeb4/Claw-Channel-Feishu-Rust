meta {
  name: open-lark WebSocket Endpoint (SDK Path)
  type: http
  seq: 4
}

post {
  url: {{feishu_base_url}}/callback/ws/endpoint
  body: json
  auth: none
}

headers {
  Content-Type: application/json
  locale: zh
}

body:json {
  {
    "AppID": "{{app_id}}",
    "AppSecret": "{{app_secret}}"
  }
}

assert {
  res.status: eq 200
  res.body.code: eq 0
  res.responseTime: lt {{max_response_time_ms}}
}

script:post-response {
  if (res.body && res.body.code === 0) {
    const wsUrl = res.body.data?.URL || res.body.data?.url;
    const config = res.body.data?.ClientConfig;

    if (wsUrl) {
      bru.setEnvVar("ws_endpoint_url", wsUrl);
      console.log("✓ WS endpoint obtained (open-lark SDK path)");
      console.log("  URL:", wsUrl.substring(0, 80) + "...");
    }

    if (config) {
      console.log("  PingInterval:", config.PingInterval, "s");
      console.log("  ReconnectCount:", config.ReconnectCount);
      console.log("  ReconnectInterval:", config.ReconnectInterval, "s");
      console.log("  ReconnectNonce:", config.ReconnectNonce, "s");
    }

    console.log("");
    console.log("ℹ open-lark SDK equivalent:");
    console.log("  LarkWsClient::open(Arc::new(config), event_handler).await");
    console.log("  // SDK internally calls /callback/ws/endpoint");
    console.log("  // Then opens WSS connection with auto-reconnect");
  }
}

tests {
  test("open-lark: WS endpoint should return valid URL", function() {
    const url = res.body.data?.URL || res.body.data?.url;
    expect(url).to.be.a('string');
    expect(url).to.match(/^wss:\/\//);
  });

  test("open-lark: ClientConfig should have reconnect params", function() {
    const config = res.body.data?.ClientConfig;
    expect(config).to.exist;
    expect(config.PingInterval).to.be.greaterThan(0);
    expect(config.ReconnectInterval).to.be.greaterThan(0);
  });

  test("open-lark: endpoint auth uses AppID+AppSecret (not Bearer)", function() {
    // Validated by request structure: body contains AppID/AppSecret
    // NOT using Authorization: Bearer header
    expect(res.body.code).to.equal(0);
  });

  test("open-lark: LarkWsAdapter thread-safety workaround validated", function() {
    // EventDispatcherHandler is !Send, so LarkWsAdapter spawns
    // a dedicated std::thread with new_current_thread runtime
    // This test validates the endpoint is reachable for the adapter
    expect(res.body.code).to.equal(0);
  });
}

docs {
  # open-lark WebSocket Endpoint - SDK Path Validation

  Validates the WebSocket endpoint that open-lark's LarkWsClient uses
  internally to establish long-lived event connections.

  ## Architecture mapping

  ```
  clawrs-feishu (facade)
    └─ feishu-platform (capability)
       └─ LarkWsAdapter (adapter)
          └─ open-lark: LarkWsClient::open(config, event_handler)
             └─ POST /callback/ws/endpoint  (this test)
             └─ WSS connect to returned URL
             └─ EventDispatcherHandler processes events
  ```

  ## Thread-safety design

  ```
  LarkWsAdapter::listen()
    ├─ std::thread::spawn()     // Dedicated OS thread
    │   └─ tokio::runtime::Builder::new_current_thread()
    │       └─ LarkWsClient::open(config, handler)  // !Send handler OK
    └─ mpsc::Sender<ChannelMessage>  // Cross-thread communication
  ```

  EventDispatcherHandler is not Send, so it must run on a single-threaded
  runtime. The mpsc channel bridges messages back to the async world.
}
