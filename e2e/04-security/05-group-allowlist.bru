meta {
  name: Group Allowlist - Check chat_id not sender
  type: http
  seq: 5
}

post {
  url: {{zeroclaw_gateway_url}}/webhook
  body: json
  auth: none
}

headers {
  Content-Type: application/json
}

body:json {
  {
    "schema": "2.0",
    "header": {
      "event_id": "test_group_allowlist_{{$randomInt}}",
      "event_type": "im.message.receive_v1",
      "create_time": "{{$timestamp}}",
      "token": "test_token",
      "app_id": "{{app_id}}",
      "tenant_key": "test"
    },
    "event": {
      "sender": {
        "sender_id": {
          "open_id": "ou_group_member_any"
        }
      },
      "message": {
        "message_id": "om_group_allowlist_test",
        "chat_id": "{{test_group_chat_id}}",
        "chat_type": "group",
        "message_type": "text",
        "content": "{\"text\":\"[E2E] E2E-04-05 @Bot group message test\"}",
        "mentions": [
          {
            "key": "@_user_1",
            "id": { "open_id": "ou_bot" },
            "name": "Bot"
          }
        ]
      }
    }
  }
}

assert {
  res.status: eq 200
}

script:pre-request {
  console.log("â„¹ Testing group allowlist (groupAllowFrom = group IDs)");
  console.log("  Group chat_id:", bru.getEnvVar("test_group_chat_id"));
  console.log("  Sender:", "ou_group_member_any");
  console.log("  Expected: groupAllowFrom must contain chat_id (oc_xxx), NOT sender open_id");
}

script:post-response {
  console.log("âœ“ Webhook accepted (200)");
  console.log("  Group allowlist: groupAllowFrom contains group IDs (oc_xxx)");
  console.log("");
  console.log("ğŸ” Verification:");
  console.log("  1. Configure groupAllowFrom: [\"{{test_group_chat_id}}\"] in channels.feishu");
  console.log("  2. Message from allowlisted group should be processed");
  console.log("  3. Message from non-allowlisted group should be dropped (check logs)");
}

tests {
  test("F-004: group webhook should return 200", function() {
    expect(res.status).to.equal(200);
  });

  test("groupAllowFrom checks chat_id not sender", function() {
    // Semantic: groupAllowFrom contains group IDs (oc_xxx), filter uses msg.channel
    expect(res.status).to.equal(200);
  });
}

docs {
  # F-004: ç¾¤ç»„ç™½åå• â€” groupAllowFrom è¯­ä¹‰

  **åŠŸèƒ½éœ€æ±‚**: F-004 ç¾¤ç»„å®‰å…¨è¿‡æ»¤ï¼ˆMustï¼‰
  **åœºæ™¯**: groupAllowFrom å­˜çš„æ˜¯ç¾¤ IDï¼ˆoc_xxxï¼‰ï¼Œæ ¡éªŒæ—¶ä½¿ç”¨ chat_id è€Œé sender
  **ä¼˜å…ˆçº§**: Must

  ## éªŒæ”¶æ¡ä»¶

  ```gherkin
  Given groupPolicy = "allowlist"
  And groupAllowFrom = ["oc_allowed_group"]
  When æ”¶åˆ°æ¥è‡ªç¾¤ oc_allowed_group çš„æ¶ˆæ¯ï¼ˆä»»æ„å‘é€è€…ï¼‰
  Then æ¶ˆæ¯è¢«å¤„ç†
  When æ”¶åˆ°æ¥è‡ªç¾¤ oc_denied_group çš„æ¶ˆæ¯
  Then æ¶ˆæ¯è¢«æ‹’ç»
  ```

  ## å®ç°æ˜ å°„

  ```rust
  // filter.rs - ä½¿ç”¨ msg.channel (ç¾¤ID) è€Œé msg.sender (ç”¨æˆ·ID)
  if is_group {
      if !params.security.is_group_allowed(&msg.channel) {
          return false;
      }
  }
  ```

  ## å‚è€ƒ

  - feishu-src bot.ts: senderId: ctx.chatId for group check
  - SecurityGuard::is_group_allowed(group_id)
}
